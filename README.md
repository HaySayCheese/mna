mna
===

Реалізація [Нормальних Алгоритмів Маркова (МНА)](http://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC "Нормальних Алгоритмів Маркова (МНА)") на С++.

Реалізовано всі передбачені даною мат. моделлю операції, в тому числі задання вихідного алфавіту Т та вихідного слова V, над яким проводяться перетворення, описані в інструкціях для виконання інтерпритатором.


#Синтаксис
###Завантаження алфавіту
Алфавіт задається множиною `T={u1, u2, ... un}`, кожен елемент якої вважається окремим символом. Інтерпритор завантаижить всі символи, що розташовані між відкриваючою фігурною дужкою `{` та закриваючою фігурною дужкою `}`, всі інші символи, що розташовано за `}` буде проігнороано.

За теорією НАМ, символ алфавіту є дискретним, тобто не може мати складових частин. З огляду на це, інтерпритатор підтримує ініціалізацію алфавіту ASCII-символами лат. алфавіту, що можуть бути записані одним із наступних способів:

`T={qwerty}` - ініціалізація алфавіту символами `q`, `w`, `e`, `r`, `t`, `y`, кожен з яких інтерпритується окремо.

Для зручності читання вихідних кодів введено можливість розділяти символи алфавіту комою, наприклад:

`T={q,w,e,r,t,y}`. В даному випадку, символ коми буде проігноровано інтерпритором як символ-розділювач. Якщо ж виникне необіхдність використати як символ алфавіту також і символ коми, тоді його слід спеціальним чином екранувати за допомогою символу `\`. Послідовність символів `\,` вкаже інтерпритатору на необхідність завантаження коми як окремого символу, наприклад:

`T={q,w,e,r,t,y,\,}`

Аналогічно слід вчинити із символом `\`, якщо виникне необхідність використати його я символ алфавіту. Приклад:

`T={q,w,e,r,t,y,\\}`

В даній реалізації, символи алфавіту можуть дублюватись, відповідне повідомлення про дублювання символу буде показано користувачу у виводі інтерпритатора, проте це не призводить до його аварійної зупинки. Також, інтерпритатор не зупиняється, якщо в інструкціях зустрічаютсья символи, що не є визначеними в алфавіті, хоча повідомлення про це користувачу також показується. 


###Завантаження вихідного слова
Вихідним словом вважається слово, над яким виконуватимуться операції, визначені іструкціями машини. Вихідне слово задається наступним чином:

`V=qwerty` - де, `V=` директива завантаження вихідного слова, а всі символи, розміщені праворуч від `=` є символами вихідного слова.


###Перелік інструкцій для виконання
Інструкціями НАМ вважаються записи виду:

`[замінюване]->[замінник]` `(1)` та `[замінюване]->.[замінник]` `(2)`

*Для більш розширеного опису призначення даних конструкцій моделі - перегляньте теорію НАМ, за посиланням вище.*

###Поведінка інтерпритора
0. Після успішного виконання інструкції - наступною буде виконано першу інструкцію зі списку, а не наступну.
0. Після виконання будь-якої інструкції першим символом опрацьовуваного слова завжди буде "!" (аналог символу лямбда, що застосовується в теорії НАМ для позначення початку опрацьовуваного слова).
0. Якщо замінник буде визначено як "!" - замінюване буде видалено із опрацьовуваного слова, оскільки символ "!" інтерпритується як нульовий символ.
0. Після виконання будь-якої інструкції останнім символом опрацьовуваного слова завжди буде "@" (деяке послаблення теорії НАМ, для легшого визначення останнього символу в слові).
0. Інтерпритатор завершить власну роботу, якщо на певній ітерації не виконаєтсья жодна інструкція зі списку.



### Приклад НАМ-програми для даного інтерпритатора
Розглянемо програму, яка замінить у виразі "abra-kadabra" всі символи "а" на "u". 

`t={abr-kdu}`

`v=abra-kadabra`

`a->u`


### Ліцензія
Public domain.

### Інше
Файл .pro - файл проекту для Qt Creator.